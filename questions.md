## Список теоритических вопросов по C# со скрытыми ответами для самопроверки
Ответы даны не мной (скорей всего обычными программистами) и могут содержать ошибки, поэтому нет смысла заучивать ответы. Однако, если вы не можете ответить на какой-то вопрос или ваш ответ сильно отличается от приведенного здесь, то вероятно у вас пробелы по данному вопросу и стоит провести более глубокое его изучение. В любом случае, не надо относиться к этим вопросам и ответам слишком серьезно.

Нумерация согласно [источнику вопросов](https://metanit.com/sharp/interview/), все практические вопросы пропущены.   
Автор ответов - [@maddevelop](https://teletype.in/@maddevelop).   
Хорошие ответы есть и у [Stanislav_Panteleev](http://digital-flame.ru/2018/08/25/c-voprosyi-i-otvetyi-k-sobesedovaniyu-chast-1/).

<details><summary>Вопрос 9. Является ли тип List потокобезопасной (thread-safe) коллекцией?</summary>

>Тип List может быть потокобезопасным в операциях чтения.   
>Пользовательский код должен обеспечивать всю синхронизацию при параллельном добавлении элементов в несколько потоков или удалении элементов из них.
</details>

<details><summary>Вопрос 10. В чем различие между операцией cast (приведения типов) и оператором as?</summary>

>В случае ошибки cast выбрасывает исключение InvalidCastException, а оператор as возвращает null
</details>

<details><summary>Вопрос 11. Какова алгоритмическая сложность для операций чтения и записи для коллекции Dictionary?</summary>

>Чтение очень быстрое, потому что используются хэш-таблицы и сложность в этом случае стремится к O(1).   
>Запись проходит тоже очень быстро (O(1)), в том случае если .Count меньше емкости, если же больше, то скорость стремится к O(n).
</details>

<details><summary>Вопрос 12. В чем различие между ключевыми словами "ref" и "out"?</summary>

>Параметр с ключевым слово out может быть не инициализирован, а параметр с ключевым словом ref обязательно должен быть инииализирован до вызова метода, который использует эти параметры.
</details>

<details><summary>Вопрос 15. В чем отличие необязательных параметров от именованных?</summary>

>Необязательные параметры позволяют опускать аргументы функции, в то время как именованные параметры разрешают передавать аргументы по названию параметра.   
>Можно, например присвоить второму и третьему параметру функции значения по-умолчанию:
```csharp
public void optionalParamFunc(int p1, int p2 = 2, int p3 = 3); 
optionalParamFunc(1, p3:10); //это эквивалентно optionalParamFunc(1,2,10);
```
</details>

<details><summary>Вопрос 16. Чем отличаются друг от друга классы String и StringBuilder?</summary>

>Объект класса String представляет собой неизменяемую строку.   
>Когда выполняется какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места.   
>Объект класса StringBuilder представляет собой динамическую строку.   
>При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке, а при добавлении к ней каких-либо элементов строка не пересоздается заново.   
>В том случае если выделенной памяти не будет хватать для добавления новых элементов, то емкость объекта будет увеличена.
</details>

<details><summary>Вопрос 17. Какие отличие между значимыми и ссылочными типами?</summary>

>Значимые типы (value type) хранятся в стеке. Стек - это структура данных, которая растет снизу вверх: каждый новый элемент помещаются поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве. А ссылочные типы (reference type) хранятся в куче, это другая область памяти, которую можно представить как неупорядоченный набор различных объектов. Когда создаётся объект ссылочного типа в стеке помещается ссылка на адрес в куче. Когда этот объект перестает использоваться, то ссылка уничтожается, а память в куче очищается.
</details>

<details><summary>Вопрос 18. Как и зачем использовать конструкцию using в C#?</summary>

>Ключевое слово using упрощает работу с объектами которые реализуют интерфейс IDisposable.   
>Интерфейс IDisposable содержит один метод .Dispose(), который используется для освобождения ресурсов, которые захватил объект. При использовании using не обязательно явно вызывать .Dispose() для объекта.
</details>

<details><summary>Вопрос 19. В чем отличие использования Finalize и Dispose?</summary>

>Dispose нужен для освобождения ресурсов "здесь и сейчас" (а точнее вызов Dispose сигнализирует, что нужно освободить ресурс, но не факт это случится в тот же момент). Необходимость и преимущество интерфейса IDisposable именно в том, что его реализация позволяет освобождать ресурсы не тогда, когда до них доберется сборщик мусора, а тогда, когда это нужно программисту. Ресурсы могут быть дорогими, и держать их в памяти неопределенно долгое время может быть слишком расточительным.   
>Что качается деструкторов в C#, то их нет вовсе, но есть финализаторы. Разница в том, что время вызова финализатора не определено. Его вызвать вручную нельзя это делается автоматически, в отличии от Dispose, который предназначен для такого.   
>Finalize выполняется перед уничтожением объекта. Можно сказать, что это "последний шанс" освободить ресурсы корректно. Определять этот метод имеет смысл только в случае, если класс имеет доступ к каким-либо неуправляемым ресурсам.
</details>

<details><summary>Вопрос 20. В чем основные отличия класса от структуры в языке C#?</summary>

>Основные отличия класса от структуры следующие: 
>    * Структура является размерным типом, а класс – ссылочным.
>    * Все структурные типы неявно наследуются от System.ValueType, они не бывают абстрактными и всегда неявно запечатаны (sealed)
>    * При присваивании переменных структурного типа, создается копия данных
>    * Объявления полей структуры не могут иметь инициализаторов
>    * Различная интерпретация this для структуры и класса
>    * Структура не может содержать конструктор без параметров
>    * Структура не может содержать деструктор
>    * Для ссылочных типов значение по умолчанию – null
>    * При конвертировании между ссылочным и размерным типами происходит упаковка и распаковка.
</details>

<details><summary>Вопрос 21. Как можно сравнить строки в C#?</summary>

>Согласно MSDN существует несколько методов для сравнения строк:
>    * String.Compare - Сравнивает значения двух строк. Возвращает целочисленное значение.   
>    * String.CompareOrdinal - Сравнивает две строки без учета локального языка и региональных параметров.Возвращает целочисленное значение.   
>    * String.CompareTo - Сравнивает текущий строковый объект с другой строкой. Возвращает целочисленное значение.   
>    * String.StartsWith - Определяет, начинается ли строка с переданной строки. Возвращает логическое значение.   
>    * String.EndsWith - Определяет, заканчивается ли строка переданной строкой. Возвращает логическое значение.   
>    * String.Equals - Определяет, совпадают ли две строки. Возвращает логическое значение.   
>    * String.IndexOf - Возвращает индекс позиции символа или строки начиная с начала проверяемой строки. Возвращает целочисленное значение.   
>    * String.LastIndexOf - Возвращает индекс позиции символа или строки начиная с конца проверяемой строки. Возвращает целочисленное значение.   
>    * Так же можно использовать операторы != и ==.
</details>

<details><summary>Вопрос 22. Что такое управляемый код и CLR? Основные требования к управляемому коду.</summary>

>Управляемый код - код программы исполняемый под управлением CLR (Виртуальной машиной .Net).   
>CLR (общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.   
>Написанный управляемый код должен быть полностью совместим с CTS(Common Type System), который поддерживают все .Net совместимые языки.
</details>
	
<details><summary>Вопрос 23. Разница IEnumerable<T> и IQueryable<T> при работе с удаленной БД?</summary>

>IEnumerable. Объект IEnumerable представляет набор данных в памяти и может перемещаться по этим данным только вперед.   
>IQueryable. Он располагается в пространстве имен System.Linq. Объект предоставляет удаленный доступ к базе данных и позволяет перемещаться по данным как в прямом порядке от начала до конца, так и в обратном порядке. В процессе же выполнения запроса, происходит оптимизация запроса.
```csharp
IEnumerable<Phone> phoneIEnum = db.Phones;
var phones1 = phoneIEnum.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES, фильтрация на стороне клиента
IQueryable<Phone> phoneIQuer = db.Phones;
int id = 3;
var phones2 = phoneIQuer.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES WHERE ID > 3
```
</details>

<details><summary>Вопрос 24. Что такое абстракция и как она связана с ООП?</summary>

>Под абстракцией понимается модель реальной жизни упрощенная для решения конкретной задачи, которая выражена в объекте, т.е. любой объект - это абстракция, т.к. она только частично описывает реальную сущность. Поэтому любой объект можно считать абстракцией и он только частично описывает реальную сущность. Во время преобразования реальных сущностный в объект, то он лишается тех характеристик, которые являются несущественными деталями.   
>Например можно составить упрощенный класс человека, который умеет двигаться, а от всего остального мы абстрагируемся (в данным случае несущественно то, что он умеет дышать, кушать, видеть, слышать и т. д.)
</details>

<details><summary>Вопрос 25. Что такое IoC (Inversion of Control/инверсия управления) и для чего она нужна?</summary>

>Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
</details>
	
<details><summary>Вопрос 26. Что такое DI (Dependency Injection) контейнер?</summary>

>DI контейнер это один из способов реализации принципа IoC. Этот контейнер знает о всех интерфейсах и их реализациях в системе и умеет их сопоставлять. Перед началом работы с ним необходимо зарегистрировать известные типы и их сопоставления(интерфейс-->реализация).
</details>

<details><summary>Вопрос 27. Какие реализации DI контейнеров вы знаете на C#. Какой DI контейнер является лучшим?</summary>

>Castle Windsor, Autofac, Ninject, Unity...и так далее, на самом деле их очень много. На счет того, какой из них лучший не совсем корректный вопрос. Все зависит от конкретной реализации.
</details>

<details><summary>Вопрос 28. Что подразумевается под свойствами в C#?</summary>

>В C# существуют специальные методы доступа, которые и именуются свойствами. Они обеспечивают простой доступ к полям класса для получения или установки их значения
>Стандартной определение свойства содержит блоки get и set. В блоке get возвращается значение поля, а в блоке set устанавливается с помощью параметра value, которое представляет передаваемое значение.
</details>

<details><summary>Вопрос 29. Что такое assembly manifest (манифест сборки)?</summary>

>Манифест сборки содержит все метаданные, необходимые для задания требований сборки к версиям и удостоверения безопасности, а также все метаданные, необходимые для определения области действия сборки и разрешения ссылок на ресурсы и классы. Манифест сборки может храниться в PE-файле (EXE или DLL) с кодом MSIL или же в отдельном PE-файле, содержащем только данные манифеста.   
>Манифест сборки предназначен для следующих задач:
>    * перечисление файлов, составляющих сборку;
>    * сопоставление ссылок на типы и ресурсы сборки с файлами, содержащими объявления и реализации этих типов и ресурсов;
>    * перечисление других сборок, от которых зависит эта сборка;
>    * обеспечение косвенного обращения пользователей сборки к подробностям ее реализации;
>    * предоставление собственного описания сборки;
</details>
	
<details><summary>Вопрос 30. Что такое GAC? Возможно ли поместить два файла с одинаковым именем в Global Assembly Cache?</summary>

>GAC (Global Assembly Cache) - глобальный кэш сборок, место где хранятся разделяемые сборки. Местоположение кэша сборок отличается в зависимости от версии .NET, установленной на локальной машине.
>В GAC нельзя помещать полностью одинаковые сборки (сборки с полностью совпадающим сложным именем). Сложное имя сборки состоит из нескольких частей:
>    * Имя сборки без расширения
>    * Номер версии. Благодаря разграничению по версии можно использовать разные версии одной и ой же сборки
>    * Открытый ключ
>    * Необязательное значение для культуры (при локализации сборки)
>    * Цифровая подпись, которая создается с помощью хэш-значения содержимого сборки и значения секретного ключа. Секретный ключ представляет собой файл с расширением *.snk.
>Так, что если совпадает у двух сборок только имена сборки, а все остальное отличается, то их можно помещать в GAC вместе.
</details>
	
<details><summary>Вопрос 31. Какие модификаторы доступа существуют в C#?</summary>

Ответ: В C# применяются следующие модификаторы доступа:

    public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
    private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.
    protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
    internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).
    protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
    private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.
</details>
	
<details><summary>Вопрос 32. Что такое Boxing и Unboxing?</summary>

Ответ: Упаковка представляет собой процесс преобразования типа значения в тип object или в любой другой тип интерфейса, реализуемый этим типом значения. Когда тип значения упаковывается средой CLR, она создает оболочку значения внутри System.Object и сохраняет ее в управляемой куче. Операция распаковки извлекает тип значения из объекта. Упаковка является неявной; распаковка является явной.Понятия упаковки и распаковки лежат в основе единой системы типов C#, в которой значение любого типа можно рассматривать как объект. Ссылка.
</details>
	
<details><summary>Вопрос 33. В чем суть полиморфизма?</summary>

Ответ:  Полиморфизм – это различная реализация однотипных действий. Классическая фраза, которая коротко объясняет полиморфизм – «Один интерфейс, множество реализаций». Полиморфизм позволяет писать более абстрактные, расширяемые программы, один и тот же код используется для объектов разных классов, улучшается читабельность кода. Полиморфизм позволяет избавить разработчика от написания, чтения и отладки множества if-else/switch-case конструкций.

Понятие полиморфизма несет за собой еще несколько определений:

    Виртуальный метод – это метод, который МОЖЕТ быть переопределен в классе-наследнике. Такой метод может иметь стандартную реализацию в базовом классе.
    Абстрактный метод – это метод, который ДОЛЖЕН быть реализован в классе-наследнике. При этом, абстрактный метод не может иметь своей реализации в базовом классе (тело пустое), в отличии от виртуального.
    Переопределение метода – это изменение реализации метода, установленного как виртуальный (в классе наследнике метод будет работать отлично от базового класса).
</details>
	
<details><summary>Вопрос 34. Какие типы можно использовать в предложении foreach?</summary>

Ответ: Можно использовать типы, которые реализуют интерфейс System.Collections.IEnumerable или System.Collections.Generic.IEnumerable<T>. Либо же к любым типам которые удовлетворяют следующим условиям:

    включают открытый метод GetEnumerator без параметров с классом, структурой или тип интерфейсом в качестве возвращаемого значения;
    тип возвращаемого значения метода GetEnumerator должен содержать открытое свойство Currentи открытый метод MoveNext без параметров с типом возвращаемого значения Boolean.
</details>
	
<details><summary>Вопрос 35. Чем отличается event от delegate?</summary>

Ответ: Event (событие) — это формализация паттерна наблюдатель на уровне спецификации языка.

В данном паттерне предполагается, что подписчик может подписать или отписать себя у издателя, но не может подписать или отписать других подписчиков. И когда происходит уведомление зависит только от издателя, а не от кого-то другого.

Именно это ограничение и накладывает событие, в отличие от делегата: это делегат, находящийся под полным контролем объекта, являющегося его собственником.

В следующем примере можно отписать все методы, добавившие себя в делегат хх, простым присвоением null:

xx.Method = null;

С событием так не получится, только если точно знать, какой объект и каким методом на него подписан.

То же самое с отработкой события: в примере с делегатом можно заставить издателя послать уведомление, когда захочется

xx.Method();

С событием так не получится: его может запускать только из класса, в котором он объявлен. Даже из наследника напрямую не удастся запустить.
</details>
	
<details><summary>Вопрос 36. Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Если да, то каким образом?</summary>

Ответ: Если класс реализует два интерфейса, содержащих член с одинаковой сигнатурой, при реализации такого члена в классе оба интерфейса будут использовать этот член в качестве собственной реализации. 

Пример (все вызовы Paint приводят к вызову одного и того же метода)

class Test 
{
    static void Main()
    {
        SampleClass sc = new SampleClass();
        IControl ctrl = sc;
        ISurface srfc = sc;

        // The following lines all call the same method.
        sc.Paint();
        ctrl.Paint();
        srfc.Paint();
    }
}

interface IControl
{  void Paint();  }
interface ISurface
{  void Paint();  }

class SampleClass : IControl, ISurface
{
    // Both ISurface.Paint and IControl.Paint call this method. 
    public void Paint()
    {
        Console.WriteLine("Paint method in SampleClass");
    }
}

// Результат:
// Paint method in SampleClass
// Paint method in SampleClass
// Paint method in SampleClass

Если два метода интерфейса выполняют разные действия, это может привести к некорректной реализации одного или обоих интерфейсов. Метод интерфейса можно реализовать явно, создав метод класса, который вызывается только через этот интерфейс и относится только к нему. Для этого в имени члена класса указывается имя интерфейса. 

Например:

public class SampleClass : IControl, ISurface
{
    void IControl.Paint()
    {
        System.Console.WriteLine("IControl.Paint");
    }
    void ISurface.Paint()
    {
        System.Console.WriteLine("ISurface.Paint");
    }
}

Метод класса IControl.Paint доступен только через интерфейс IControl, а ISurface.Paint — только через интерфейс ISurface. Обе реализации метода будут разделены, и ни одна из них не будет доступна в классе напрямую. 

Например:

// Вызов метода Paint через Main

SampleClass obj = new SampleClass();
//obj.Paint();  // Compiler error.

IControl c = obj;
c.Paint();  // Вызываем IControl.Paint из SampleClass.

ISurface s = obj;
s.Paint(); // Вызываем ISurface.Paint из SampleClass.

// Результат:
// IControl.Paint
// ISurface.Paint

Явная реализация также применяется в случаях, когда в каждом из двух интерфейсов объявляются разные члены (например, свойство и метод) с одинаковыми именами:

interface ILeft
{
    int P { get;}
}
interface IRight
{
    int P();
}

Чтобы реализовать оба интерфейса и избежать ошибок компилятора, класс должен использовать явную реализацию либо свойства P, либо метода P, либо одновременно обоих этих членов.

class Middle : ILeft, IRight
{
    public int P() { return 0; }
    int ILeft.P { get { return 0; } }
}
</details>
	
<details><summary>Вопрос 37. Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?</summary>

Ответ: System.Array.CopyTo() - копирует все элементы текущего одномерного массива в заданный одномерный массив.

public void CopyTo (Array array, int index);
Пример:
mySourceArray.CopyTo( myTargetArray, 6 );

System.Array.Clone() - Создает неполную копию Array.

public object Clone ();
Пример
CultureInfo[] arrCIClone = (CultureInfo[]) arrCI.Clone();

Оба метода выполняют неглубокую копию. Неглубокая копия означает, что содержимое нового массива (каждый элемент) содержит ссылки на тот же объект, что и элементы в исходном массиве. Глубокая копия (которая не выполняется ни одним из этих методов) создаст новый экземпляр объекта каждого элемента, что приведет к другому, но идентичному объекту.

Так что разница есть:

1- CopyTo require to have a destination array when Clone return a new array. 
2- CopyTo let you specify an index (if required) to the destination array. 
</details>
	
<details><summary>Вопрос 38. Что такое абстрактный класс? В каком случае вы обязаны объявить класс абстрактным?</summary>

Ответ: Абстрактный класс очень похож на обычный класс, он так же содержит обычные методы, свойства, поля. Единственное, что при определении абстрактного класса используется ключевое слова abstract. Главное же отличие его от обычного класса в том, что нельзя использовать стандартный конструктор для создания объекта класса, т.е. так сделать не получится:

Human chelik = new Human();

Абстрактные классы нужны для того, чтобы выделять общий функционал от нескольких классов в обособленный класс. От этого отдельного класса потом можно унаследовать либо просто сигнатуру функционала, либо вместе с реализацией.

Класс обязательно нужно объявлять как абстрактный когда он содержит абстрактные члены. Источник
</details>
	
<details><summary>Вопрос 39. Назовите отличия между интерфейсом и абстрактным классом?</summary>

Ответ: В плане определения функционала без конкретной реализации у абстрактных классов и интерфейсов много общего. Часто в программах можно заменять абстрактные классы на интерфейсы и наоборот. Но все же имеются отличия.

Когда лучше использовать абстрактные классы:

    Для определения общего функционала для родственных объектов
    Для проектирования большой функциональной единицы, которая содержит обширный базовый функционал
    Для того, чтобы все производные классы на всех уровнях наследования имели некоторую общую реализацию. При использовании абстрактных классов, для изменения базового функционала во всех наследниках достаточно поменять его в абстрактном базовом классе.
    Для смены названия или параметра метода интерфейса нужно внести изменения и также во все классы, которые данный интерфейс реализуют.

Когда лучше использовать интерфейсы:

    Для определения функционала для группы разрозненных объектов, которые могут быть никак не связаны между собой.
    Для проектирования небольшого функционального типа.
</details>
	
<details><summary>Вопрос 40. В чем разница между абстрактными и виртуальными классами? Между виртуальными и абстрактными методами?</summary>

Ответ: Абстрактные классы это класс помеченный ключевым словом abstract. В таком классе мы не можем использовать конструктор для создания объекта класса. В абстрактном классе содержатся абстрактные члены (методы, свойства, индексаторы, события) они не имеют внутренней реализации и выступают в роли интерфейса. Они так же обязаны быть помечены ключевыми словом abstract. При наследовании от абстрактного класса, класс наследник получает все свойства своего класса родителя, а если в родительском классе есть еще и абстрактные члены, то в классе наследнике обязательно их нужно переопределять.

Виртуальный класс, это просто класс в котором есть виртуальные члены (методы, свойства...) Виртуальные члены помечаются модификатором virtual и имеют внутреннюю реализацию, которая может быть переопределена в классе наследнике.
</details>
	
<details><summary>Вопрос 41. Что означает модификатор virtual?</summary>

Ответ: Модификатор virtual служит для того, чтобы помечать виртуальные методы или свойства в классе родителя. Виртуальные методы (свойства) - это такие методы, которые мы хотим переопределить в классах наследниках. А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override. Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
</details>
	
<details><summary>Вопрос 42. В чем разница инкапсуляции и сокрытия?</summary>

Ответ: Инкапсуляция - одна из парадигм ООП. Она представляет собой способность языка упаковывать определённые участки кода в контейнеры, исключая возможность внешнего мира нарушения целостности данного кода. Основной единицей инкапсуляции в C# является класс. Инкапсуляция позволяет структурировать код и помогает обезопасить его от многих возможных проблем, относительно защиты данных и информации.

Сокрытие же скрывает детали о процессе. Для определения прав доступа к данным в классе и к классу непосредственно используются модификаторы доступа. Получается, что использование этих модификаторов и есть то самое сокрытие.

Но сам термин "сокрытие" лучше употреблять в контексте методов. Сокрытие метода представляет собой реализация тела метода в дочернем классе, сигнатура которого соответствует сигнатуре метода в родительском классе. Для сокрытия применяется ключевое слово "new".

Пример.

class Animal
{
    public void Say()
    {
        Console.WriteLine("*Some sounds*");
    }
}
class Cat:Animal
{
    public new void Say()// the usage of hiding technique
    {
        Console.WriteLine("Miew!");
    }
}

Лучше термин "сокрытие" использовать в контексте именно сокрытия метода, потому что нет определённого правила отличия инкапсуляции и сокрытия, и на этом фоне могут плявляться разные споры.
</details>
	
<details><summary>Вопрос 43. Что такое частные и общие сборки?</summary>

Ответ: Частные сборки:

    Видны только самому приложению
    Нет необходимости заботиться об уникальном имени во всем глобальном пространстве имен
    Не нужно делать записей в реестре при развертывании приложения
    Сборки просто копируются в директорию приложения или в подчинённую директорию
    Общая среда выполнения (CLR) при запуске приложения прочитает его манифест и определит какие сборки необходимы. Затем будет произведен поиск нужной сборки по директории приложения (процесс зондирования)

Общие сборки:

    Общие сборки могут быть использованы сразу несколькими приложениями
    Сборка должна иметь строгое имя (strong name)
    Сборка должна быть помещена в общедоступное место – Global Assembly Cache (GAC, глобальный кэш сборок)
</details>
	
<details><summary>Вопрос 44. Что такое .Net Framework?</summary>

Ответ: .NET Framework — программная платформа, выпущенная компанией Microsoft в 2002 году. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), которая подходит для разных языков программирования. Функциональные возможности CLR доступны в любых языках программирования, использующих эту среду.

(Источник Википедия)
</details>
	
<details><summary>Вопрос 45. Чем управляемый код (managed code) отличается от неуправляемого (unmanaged code)?</summary>

Ответ: Управля́емый код (managed code) — термин, введённый фирмой Microsoft, для обозначения кода программы, исполняемой под «управлением» виртуальной машины .NET — Common Language Runtime или Mono. При этом машинный код называется неуправля́емым кодом (unmanaged code).

Слово «управляемый» относится к методу обмена информацией между программой и исполняющей средой. Оно означает, что в любой точке исполнения управляющая среда может приостановить исполнение и получить информацию, специфичную для текущего состояния. Необходимая для этого информация представлена в управляемом коде на языке Intermediate Language и в связанных с этим кодом метаданных.

С формальной точки зрения управляемым кодом является любой программный код, исполняемый в среде отладчика.

(Источник Викидедия)
</details>
	
<details><summary>Вопрос 46. LINQ lazy loading, eager loading в чем разница?</summary>

Ответ:

В случае lazy loading, зависимые таблицы (дочерние объекты) не загружаются автоматически с родительскими, а загрузятся в тот момент, когда они понадобятся. В LINQ по умолчанию используется lazy loading.

Например:

var query = context.Categories.Take(3); // Lazy loading
 
foreach (var Category in query)
{
   Console.WriteLine(Category.Name);
   foreach (var Product in Category.Products)
   {
   Console.WriteLine(Product.ProductID);
   }
}

Таким образом сгенерируется следующий SQL код:

SELECT TOP (3) 
[c].[CatID] AS [CatID], 
[c].[Name] AS [Name], 
[c].[CreatedDate] AS [CreatedDate]
FROM [dbo].[Category] AS [c]
GO
 
-- Region Parameters
DECLARE @EntityKeyValue1 Int = 1
-- EndRegion
SELECT 
[Extent1].[ProductID] AS [ProductID], 
[Extent1].[Name] AS [Name], 
[Extent1].[UnitPrice] AS [UnitPrice], 
[Extent1].[CatID] AS [CatID], 
[Extent1].[EntryDate] AS [EntryDate], 
[Extent1].[ExpiryDate] AS [ExpiryDate]
FROM [dbo].[Product] AS [Extent1]
WHERE [Extent1].[CatID] = @EntityKeyValue1
GO
 
-- Region Parameters
DECLARE @EntityKeyValue1 Int = 2
-- EndRegion
SELECT 
[Extent1].[ProductID] AS [ProductID], 
[Extent1].[Name] AS [Name], 
[Extent1].[UnitPrice] AS [UnitPrice], 
[Extent1].[CatID] AS [CatID], 
[Extent1].[EntryDate] AS [EntryDate], 
[Extent1].[ExpiryDate] AS [ExpiryDate]
FROM [dbo].[Product] AS [Extent1]
WHERE [Extent1].[CatID] = @EntityKeyValue1
GO
 
-- Region Parameters
DECLARE @EntityKeyValue1 Int = 3
-- EndRegion
SELECT 
[Extent1].[ProductID] AS [ProductID], 
[Extent1].[Name] AS [Name], 
[Extent1].[UnitPrice] AS [UnitPrice], 
[Extent1].[CatID] AS [CatID], 
[Extent1].[EntryDate] AS [EntryDate], 
[Extent1].[ExpiryDate] AS [ExpiryDate]
FROM [dbo].[Product] AS [Extent1]
WHERE [Extent1].[CatID] = @EntityKeyValue1

Как видно из примера, мы получаем 4 SQL запроса. Это означает, что будет происходить 4 обращения к базе данных, один раз для таблицы Categories и 3 раза для таблицы Products, которая связана с Categories. В этом случае дочерние объекты заполняются по запросу.

Можно отключить lazy loading. Для этого нужно установить параметр LazyLoadingEnabled свойства ContextOptions объекта контекста в состояние false. После этого можно будет получать зависимые от родителя объекты при единственном запросе.

context.ContextOptions.LazyLoadingEnabled = false;

В случае eager loading, зависимые объекты загружаются автоматически с родительской таблицей. Для того, чтобы использовать eager loading нужно применить метод Include().

Например:

var query = context.Categories.Include("Products").Take(3); // Eager loading
 
 foreach (var Category in query)
 {
 Console.WriteLine(Category.Name);
 foreach (var Product in Category.Products)
 {
 Console.WriteLine(Product.ProductID);
 }
 }

Сгенерированный SQL запрос:

SELECT [Project1].[CatID] AS [CatID], 
 [Project1].[Name] AS [Name], 
 [Project1].[CreatedDate] AS [CreatedDate], 
 [Project1].[C1] AS [C1], 
 [Project1].[ProductID] AS [ProductID], 
 [Project1].[Name1] AS [Name1], 
 [Project1].[UnitPrice] AS [UnitPrice], 
 [Project1].[CatID1] AS [CatID1], 
 [Project1].[EntryDate] AS [EntryDate], 
 [Project1].[ExpiryDate] AS [ExpiryDate]
 FROM (SELECT 
 [Limit1].[CatID] AS [CatID], 
 [Limit1].[Name] AS [Name], 
 [Limit1].[CreatedDate] AS [CreatedDate], 
 [Extent2].[ProductID] AS [ProductID], 
 [Extent2].[Name] AS [Name1], 
 [Extent2].[UnitPrice] AS [UnitPrice], 
 [Extent2].[CatID] AS [CatID1], 
 [Extent2].[EntryDate] AS [EntryDate], 
 [Extent2].[ExpiryDate] AS [ExpiryDate], 
 CASE WHEN ([Extent2].[ProductID] IS NULL) THEN CAST(NULL AS int) 
ELSE 1 END AS [C1]
FROM (SELECT TOP (3) [c].[CatID] AS [CatID], [c].[Name] AS [Name], [c].[CreatedDate] AS [CreatedDate]
 FROM [dbo].[Category] AS [c] ) 
AS [Limit1]
 LEFT OUTER JOIN [dbo].[Product] AS [Extent2] 
ON [Limit1].[CatID] = [Extent2].[CatID]) AS [Project1]
 ORDER BY [Project1].[CatID] ASC, [Project1].[C1] ASC

Как можно заметить имеется только один SQL запрос. А это означает, что обращение к базе данных будет происходить только единожды для таблицы Categories и Products зависящей от нее. Таким образом, полученная выборка будет сразу содержать данные от родительской и от дочерней таблицы.

(Перевод статьи)

<details><summary>Вопрос 47. Можно ли запретить наследование от своего собственного класса?</summary>

Ответ:

Для того, чтобы запретить наследоваться от класса необходимо объявить его с модификатором sealed.

Например:

sealed class SomeClass
{
    // Объявление класса
}
</details>
	
<details><summary>Вопрос 48. Можно ли разрешить наследование класса, но запретить переопределение метода?</summary>

Ответ:

Да. Для этого нужно определить родительский класс с модификатором public, а метод в нем пометить как sealed.

Например:

class Base {
   public virtual void Test() { ... }
}
class Subclass1 : Base {
   public sealed override void Test() { ... }
}
class Subclass2 : Subclass1 {
   public override void Test() { ... } // Не скомпилируется!
}
</details>
	
<details><summary>Вопрос 49. Определение паттерна синглтон</summary>

Ответ: 

Одиночка (Singleton, Синглтон) - порождающий паттерн, который гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому объекту точку доступа. Используется тогда, когда необходимо, чтобы для класса существовал только один экземпляр. Он позволяет создать объект только при его необходимости. Если объект не нужен, то он не будет создан. В этом отличие синглтона от глобальных переменных.

Классическая реализация данного шаблона на C#:

class Singleton
{
    private static Singleton instance;
 
    private Singleton()
    {}
 
    public static Singleton getInstance()
    {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}

В классе определяется статическая переменная - ссылка на конкретный экземпляр данного объекта и приватный конструктор. В статическом методеgetInstance() этот конструктор вызывается для создания объекта, если, конечно, объект отсутствует и равен null.

(Источник)

<details><summary>Вопрос 50. Thread, task, примеры использования?</summary>

Ответ:

Класс Thread, позволяет выделить, которые будут выполняться одновременно.

Для запуска нового потока нужно определить метод, который будет выполняться в потоке. Для создания потока используется делегат ThreadStart, получающий в качестве параметра определенный ранее метод.

Для запуска потока вызывается метод Start.

using System.Threading;
 
class Program
{
    static void Main(string[] args)
    {
        // создаем новый поток
        Thread myThread = new Thread(new ThreadStart(Count));
        myThread.Start(); // запускаем поток
 
        for (int i = 1; i < 9; i++)
        {
            Console.WriteLine("Главный поток:");
            Console.WriteLine(i * i);
            Thread.Sleep(300);
        }
 
        Console.ReadLine();
    }
 
    public static void Count()
    {
        for (int i = 1; i < 9; i++)
        {
            Console.WriteLine("Второй поток:");
            Console.WriteLine(i * i);
            Thread.Sleep(400);
        }
    }
}

Новый поток будет производить действия, определенные в методе Count. Для запуска этого метода в качестве второго потока, создается объект потока: Thread myThread = new Thread(new ThreadStart(Count));. В конструктор передается делегат ThreadStart, который в качестве параметра принимает метод Count. И следующим методом myThread.Start() запускается поток. После этого управление передается главному потоку, и выполняются все остальные действия, определенные в методе Main.

Существует еще одна форма создания потока: Thread myThread = new Thread(Count); Хотя в данном случае явным образом мы не используем делегат ThreadStart, но неявно он создается. Компилятор C# выводит делегат из сигнатуры метода Count и вызывает соответствующий конструктор.

(Источник)

Класс Task, который находится в пространстве имен System.Threading.Tasks, позволяет запускать отдельную продолжительную задачу. Она запускается асинхронно в одном из потоков из пула потоков, но ее можно запускать и синхронно.

Первый способ запуска - это создание объекта Task и вызов у него метода Start:

Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();

В качестве параметра объект Task принимает делегат Action. А метод Start() запускает задачу.

Второй способ - это использование статического метода Task.Factory.StartNew(). Он в качестве параметра принимает делегат Action. При этом этот метод сразу же запускает задачу:

Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));

В качестве результата метод возвращает запущенную задачу.

Третий способ определения и запуска задач представляет использование статического метода Task.Run():

Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

Метод Task.Run() также в качестве параметра может принимать делегат Action и возвращает объект Task.

Пример:

using System;
using System.Threading.Tasks;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Task task1 = new Task(() => Console.WriteLine("Task1 is executed"));
            task1.Start();
 
            Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task2 is executed"));
 
            Task task3 = Task.Run(() => Console.WriteLine("Task3 is executed"));
             
            Console.ReadLine();
        }
    }
}

(Источник)
</details>
	
<details><summary>Вопрос 51. Что такое интеграционные тесты и unit-тесты?</summary>

Ответ:

    Unit тест: Очень специфичны. Тестирование производится над одним классом, либо над конкретным методом класса. Должна быть четко поставленная задача, чтобы проверить правильность работы элемента программы. Сложные зависимости и взаимодействия не тестируются.
    Интеграционный тест: проверяет правильность взаимодействия нескольких подсистем. Существует целый спектр вариантов, от тестирования взаимодействия между двумя классами до тестирования взаимодействия с программной средой.
</details>
	
<details><summary>Вопрос 52. Что такое MVVM?</summary>

Ответ: Паттерн MVVM (Model-View-ViewModel) позволяет отделить логику приложения от визуальной части. Он является архитектурным, (задает общую архитектуру приложения).

Паттерн был представлен Джоном Госсманом в 2005 году как модификация шаблона Presentation Model и был первоначально нацелен на разработку приложений в WPF. И хотя сейчас данный паттерн вышел за пределы WPF и применяется в самых различных технологиях, в том числе при разработке под Android, iOS, тем не менее WPF является довольно показательной технологией, которая раскрывает возможности данного паттерна.

MVVM состоит из трех компонентов: модели (Model), модели представления (ViewModel) и представления (View).
</details>
	
<details><summary>Вопрос 53. Что будет выведено в результате выполнения программы?</summary>

class Program
{
    private enum En
    {
        First = 15,
        Second,
        Third = 54
    }
    static void Main(string[] args)
    {
        Console.WriteLine((int)En.Second);
        Console.Read();
    }
}

Варианты ответов:

    0
    1
    16
    Возникнет ошибка на этапе компиляции

Ответ:  В результате выведется число 16 (ответ 3).

Потому, что при создании типа перечисления каждому элементу целочисленное значение, причем первый элемент будет иметь значение 0, второй - 1 и так далее. Первому элементу явно присваивается значение 15, а значит второму будет присвоено соответственно 16.
</details>
	
<details><summary>Вопрос 54. Когда использовать StringBuilder предпочтительнее, чем string?</summary>

    Если строка редко изменяется
    Если строка часто изменяется
    Если строка содержит спецсимволы
    Если строка содержит исключительно цифры

Ответ:

StringBuilder предпочтительнее использовать если строка часто изменяется (ответ 2).

А в более развернутом варианте можно ответить так:

Microsoft рекомендует использовать класс String в следующих случаях:

    При небольшом количестве операций и изменений над строками
    При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну
    Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StringBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:

    При неизвестном количестве операций и изменений над строками во время выполнения программы
    Когда предполагается, что приложению придется сделать множество подобных операций
</details>
	
<details><summary>Вопрос 55. Что будет выведено в результате выполнения программы?</summary>

class Program
{
    static void Main(string[] args)
    {
        int c = 3;
        Console.Write(Sum(5,3,out c)+" ");
        Console.Write(c);
        Console.ReadLine();
    }
    static int Sum(int a, int b, out int c)
    {
        return a + b;
    }
}

Варианты ответов:

    8
    8 3
    8 0
    Возникнет ошибка на этапе компиляции

Ответ: Возникнет ошибка на этапе компиляции. (ответ 4) Это произойдет в следствии того, что параметру "с" метода Sum, помеченному ключевым словом out, не присвоено значение в теле метода, а это противоречит условию использования модификатора out. Ключевое слово out нужно для того, чтобы сделать параметр "выходным". Результат метода будет получен не только через return, но и через этот параметр "с". 
</details>
	
<details><summary>Вопрос 56. Что будет выведено в результате выполнения программы?</summary>

class Program
{
    static void Main(string[] args)
    {
        var a = null;
        a = 10;
        Console.WriteLine(a);
        Console.ReadLine();
    }
}

Варианты ответов:

    0
    10
    Пустая строка
    Возникнет ошибка на этапе компиляции

Ответ: Возникнет ошибка на этапе компиляции (Ответ 4) Причина в том что нельзя присваивать значение null к неявно типизированной переменной.
	
<details><summary>Вопрос 59. Какой уровень доступа имеют поля класса, если модификатор доступа не указан?</summary>

Если не указывать модификатор доступа для поля класса, то по умолчанию они объявляются с модификатором private.

<details><summary>Вопрос 60. Каким образом можно присвоить значения полям, которые помечены ключевым словом readonly?</summary>

    С помощью атрибута DefaultValueAttribute
    В любое время из любого метода, который содержится в том же классе, что и поле
    Можно присвоить значение из любого места в коде, но только один раз
    Из конструктора, либо в месте объявления поля, приравнивая ему какое-то значение

Ответ: Поля помеченные ключевым словом readonly можно инициализировать при их объявлении либо на уровне класса, либо в конструкторе. Инициализировать или изменять их значение в других местах нельзя. (Вариант 4)
</details>
	
<details><summary>Вопрос 61. Какая из операций linq исключает дублирование одинаковых элементов в выходной последовательности?</summary>

Операция Distinct удаляет дублированные элементы из входной последовательности. (Ответ 5)
</details>
	
<details><summary>Вопрос 62. С помощью какого ключевого слова осуществляется блокировка одновременного выполнения определенных участков кода несколькими потоками?</summary>

Для осуществления блокировки одновременного выполнения определенных участков кода несколькими потоками используется ключевое слово lock. lock определяет блок, внутри которого весь код становится недоступным для других потоков до завершения работы текущего потока.
</details>
	
<details><summary>Вопрос 63. Какой интерфейс должен реализовать класс, чтобы к переменной данного типа был применим оператор foreach?</summary>

Чтобы применить к объекту какого-либо класса оператор foreach в этом классе должен быть реализован интерфейс IEnumerable (ответ 5)

Оператор foreach может применяться для переменных, которые реализуют интерфейс IEnumerable или IEnumerable<T>, либо к экземпляру любого типа, удовлетворяющим условиям:

    должен включать открытый метод GetEnumerator без параметров с классом, структурой или типом интерфейса в качестве возвращаемого значения;
    тип возвращаемого значения метода GetEnumerator должен содержать открытое свойство Current и открытый метод MoveNext без параметров с типом возвращаемого значения Boolean.
</details>
	
<details><summary>Вопрос 64. Когда вызывается статический конструктор класса?</summary>

Статический конструктор вызывается автоматически для инициализации класса перед созданием первого экземпляра типа или при первом обращении к каким-либо статическим членам.
</details>
	
<details><summary>Вопрос 65. Чем отличаются константы и поля, доступные только для чтения?</summary>

    Ничем не отличаются
    Константы инициализируются только во время компиляции, а поля, доступные для чтения, могут инициализироваться во время выполнения в конструкторе
    Поля, доступные для чтения, инициализируются только во время компиляции, а константы могут инициализироваться во время выполнения в конструкторе
    Константы можно изменять, а доступные только для чтения поля нет

Ответ: Константы являются не явно статическими и вы не можете объявить их с ключевым словом static. Поля для чтения не являются неявно статическими, и их можно сделать таковыми добавив ключевое слово static.

Значение константы должно быть задано в момент ее определения в классе. Поле только для чтения должно быть определено до завершения работы конструктора. Можно задать значение такого поля как непосредственно в строке его определения ( inline инициализация), так и в теле конструктора.
</details>
