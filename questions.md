## Список теоритических вопросов по C# со скрытыми ответами для самопроверки.
Нумерация в порядке согласно [источнику](https://metanit.com/sharp/interview/), все практические вопросы пропущены.   
Автор ответов - [@maddevelop](https://teletype.in/@maddevelop)

<details><summary>Вопрос 9. Является ли тип List потокобезопасной (thread-safe) коллекцией?</summary>


Тип List может быть потокобезопасным в операциях чтения.   
Пользовательский код должен обеспечивать всю синхронизацию при параллельном добавлении элементов в несколько потоков или удалении элементов из них.


</details>

<details><summary>Вопрос 10. В чем различие между операцией cast (приведения типов) и оператором as?</summary>

В случае ошибки cast выбрасывает исключение InvalidCastException, а оператор as возвращает null
</details>

<details><summary>Вопрос 11. Какова алгоритмическая сложность для операций чтения и записи для коллекции Dictionary?</summary>

Чтение очень быстрое, потому что используются хэш-таблицы и сложность в этом случае стремится к O(1).
Запись проходит тоже очень быстро (O(1)), в том случае если .Count меньше емкости, если же больше, то скорость стремится к O(n).
</details>

<details><summary>Вопрос 12. В чем различие между ключевыми словами "ref" и "out"?</summary>

Параметр с ключевым слово out может быть не инициализирован, а параметр с ключевым словом ref обязательно должен быть инииализирован до вызова метода, который использует эти параметры.
</details>

<details><summary>Вопрос 15. В чем отличие необязательных параметров от именованных?</summary>

Необязательные параметры позволяют опускать аргументы функции, в то время как именованные параметры разрешают передавать аргументы по названию параметра.

Можно, например присвоить второму и третьему параметру функции значения по-умолчанию:
```csharp
public void optionalParamFunc(int p1, int p2 = 2, int p3 = 3); 
optionalParamFunc(1, p3:10); //это эквивалентно optionalParamFunc(1,2,10);
```
</details>

<details><summary>Вопрос 16. Чем отличаются друг от друга классы String и StringBuilder?</summary>

объект класса String представляет собой неизменяемую строку.   
Когда выполняется какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места.   
Объект класса StringBuilder представляет собой динамическую строку.   
При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке, а при добавлении к ней каких-либо элементов строка не пересоздается заново.   
В том случае если выделенной памяти не будет хватать для добавления новых элементов, то емкость объекта будет увеличена.

<details><summary>Вопрос 17

Какие отличие между значимыми и ссылочными типами?

Ответ: значимые типы (value type) хранятся в стеке. Стек - это структура данных, которая растет снизу вверх: каждый новый элемент помещаются поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве. А ссылочные типы (reference type) хранятся в куче, это другая область памяти, которую можно представить как неупорядоченный набор различных объектов. Когда создаётся объект ссылочного типа в стеке помещается ссылка на адрес в куче. Когда этот объект перестает использоваться, то ссылка уничтожается, а память в куче очищается.
<details><summary>Вопрос 18

Как и зачем использовать конструкцию Using в C#?

Ответ: Ключевое слово Using упрощает работу с объектами которые реализуют интерфейс IDisposable.

Интерфейс IDisposable содержит один метод .Dispose(), который используется для освобождения ресурсов, которые захватил объект. При использовании Using не обязательно явно вызывать .Dispose() для объекта.

 using (SqlConnection conn = new SqlConnection()) { 
// какая-нибудь SQL операция 
} 

При этом компилятор генерирует следующий код:

SqlConnection conn = new SqlConnection(); 
try { 
 
} finally { 
    // здесь для conn вызывается .Dispose() 
} 

<details><summary>Вопрос 19

В чем отличие использования Finalize и Dispose?

Ответ: Dispose нужен для освобождения ресурсов "здесь и сейчас" (а точнее вызов Dispose сигнализирует, что нужно освободить ресурс, но не факт это случится в тот же момент). Необходимость и преимущество интерфейса IDisposable именно в том, что его реализация позволяет освобождать ресурсы не тогда, когда до них доберется сборщик мусора, а тогда, когда это нужно программисту. Ресурсы могут быть дорогими, и держать их в памяти неопределенно долгое время может быть слишком расточительным.

Что качается деструкторов в C#, то их нет вовсе, но есть финализаторы. Разница в том, что время вызова финализатора не определено. Его вызвать вручную нельзя это делается автоматически, в отличии от Dispose, который предназначен для такого.

Finalize выполняется перед уничтожением объекта. Можно сказать, что это "последний шанс" освободить ресурсы корректно. Определять этот метод имеет смысл только в случае, если класс имеет доступ к каким-либо неуправляемым ресурсам.
<details><summary>Вопрос 20

В чем основные отличия класса от структуры в языке C#?

Ответ: Основные отличия класса от структуры следующие: 

1. Структура является размерным типом, а класс – ссылочным.

2. Все структурные типы неявно наследуются от System.ValueType, они не бывают абстрактными и всегда неявно запечатаны (sealed)

3. При присваивании переменных структурного типа, создается копия данных

4. Объявления полей структуры не могут иметь инициализаторов

5. Различная интерпретация this для структуры и класса

6. Структура не может содержать конструктор без параметров

7. Структура не может содержать деструктор

8. Для ссылочных типов значение по умолчанию – null

9. При конвертировании между ссылочным и размерным типами происходит упаковка и распаковка.

<details><summary>Вопрос 21

Как можно сравнить строки в C#?

Ответ: Согласно MSDN существует несколько методов для сравнения строк:

    String.Compare - Сравнивает значения двух строк. Возвращает целочисленное значение.
    String.CompareOrdinal - Сравнивает две строки без учета локального языка и региональных параметров.Возвращает целочисленное значение.
    String.CompareTo - Сравнивает текущий строковый объект с другой строкой. Возвращает целочисленное значение.
    String.StartsWith - Определяет, начинается ли строка с переданной строки. Возвращает логическое значение.
    String.EndsWith - Определяет, заканчивается ли строка переданной строкой. Возвращает логическое значение.
    String.Equals - Определяет, совпадают ли две строки. Возвращает логическое значение.
    String.IndexOf - Возвращает индекс позиции символа или строки начиная с начала проверяемой строки.Возвращает целочисленное значение.
    String.LastIndexOf - Возвращает индекс позиции символа или строки начиная с конца проверяемой строки.Возвращает целочисленное значение.
    Так же можно использовать операторы != и ==. С их помощью строки сравниваются по значению, а если хочется сравнить строки по ссылке то можно применить такой вариант:

(object)str1 == (object)str2

Но в этом случае не стоит забывать об интернировании.
<details><summary>Вопрос 22

Что такое управляемый код и CLR? Основные требования к управляемому коду.

Ответ: управляемый код - код программы исполняемый под управлением CLR (Виртуальной машиной .Net)

CLR (общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.

Написанный управляемый код должен быть полностью совместим с CTS(Common Type System), который поддерживают все .Net совместимые языки.
<details><summary>Вопрос 23

Разница IEnumerable<T> и IQueryable<T> при работе с удаленной БД ?

Ответ: сначала нужно сказать, что:

    IEnumerable относится к System.Collection (Linq to Object)
    IQueryable относится к System.Linq (Linq to Sql)

При этом, стоит отметить, что IEnumerable родитель для IQueryable.

Разницу между ними хорошо видна при работе с БД (например технологией EF).

    IEnumerable. Объект IEnumerable представляет набор данных в памяти и может перемещаться по этим данным только вперед.

Например:

IEnumerable<Phone> phoneIEnum = db.Phones;
var phones=phoneIEnum.Where(p => p.Id > id).ToList()

в этом случае фильтрация будет идти уже после выборки всех значений из БД. То есть, при выполнении запроса, IEnumerable загружает все данные, и если требуется выполнить их фильтрацию, то она происходит на стороне клиента.

Запрос на стороне БД:

SELECT * FROM STUDENTS 

    IQueryable. Он располагается в пространстве имен System.Linq. Объект предоставляет удаленный доступ к базе данных и позволяет перемещаться по данным как в прямом порядке от начала до конца, так и в обратном порядке. В процессе же выполнения запроса, происходит оптимизация запроса.

Используем тот же пример только с IQueryable:

IQueryable<Phone> phoneIQuer = db.Phones;
var phones=phoneIQuer.Where(p => p.Id > id).ToList();

Здесь же при запросе будет производиться сразу фильтрация и будет возвращено только то, что нужно нам. Стоит отметить, что сам запрос будет отрабатываться чуть медленнее, чем запрос, возвращающий объект IEnumerable.

Запрос на стороне БД:

SELECT * FROM STUDENTS 
    WHERE AGE > 25 

<details><summary>Вопрос 24

Что такое абстракция и как она связана с ООП?

Ответ: Под абстракцией понимается модель реальной жизни упрощенная для решения конкретной задачи, которая выражена в объекте, т.е. любой объект - это абстракция, т.к. она только частично описывает реальную сущность. Поэтому любой объект можно считать абстракцией и он только частично описывает реальную сущность. Во время преобразования реальных сущностный в объект, то он лишается тех характеристик, которые являются несущественными деталями.

Например можно составить упрощенный класс человека, который умеет двигаться, а от всего остального мы абстрагируемся (в данным случае несущественно то, что он умеет дышать, кушать, видеть, слышать и т. д.)

class Man 
{
  public void Move(bool run)
  {
    if(run)
    {
      Run();	
    }
    else
    {
      Walk();
    }
  }
  private void Walk()
  {
    Console.WriteLine("Man is walking.");
  }
  private void Run()
  {
    Console.WriteLine("Man is running.");
  }
}

<details><summary>Вопрос 25

Что такое IoC(Inversion of Control/инверсия управления) и для чего она нужна?

Ответ: Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
Вопрос 26

Что такое DI(Dependency Injection) контейнер?

Ответ: DI контейнер это один из способов реализации принципа IoC. Этот контейнер знает о всех интерфейсах и их реализациях в системе и умеет их сопоставлять. Перед началом работы с ним необходимо зарегистрировать известные типы и их сопоставления(интерфейс-->реализация).
<details><summary>Вопрос 27

Какие реализации DI контейнеров вы знаете на C#. Какой DI контейнер является лучшим?

Ответ: Castle Windsor, Autofac, Ninject, Unity...и так далее, на самом деле их очень много. На счет того, какой из них лучший не совсем корректный вопрос. Все зависит от конкретной реализации.
<details><summary>Вопрос 28

Что подразумевается под свойствами в C#?

Ответ: В C# существуют специальные методы доступа, которые и именуются свойствами. Они обеспечивают простой доступ к полям класса для получения или установки их значения

[модификатор_доступа] возвращаемый_тип название
{
	//код свойства
}

Стандартной определение свойства содержит блоки get и set. В блоке get возвращается значение поля, а в блоке set устанавливается с помощью параметра value, которое представляет передаваемое значение.

private string _name;
public string Name
{
	get { return _name; }
	set { _name = value; }
}

Свойства позволяют добавить логику, которая может быть необходима, например, при присвоении переменной класса какого-либо значения. Блоки set и get не обязательно одновременно должны присутствовать в свойстве. Если свойство определяют только блок get, то такое свойство доступно только для чтения - мы можем получить его значение, но не установить. И, наоборот, если свойство имеет только блок set, тогда это свойство доступно только для записи.

Более подр��бно можно почитать здесь.
<details><summary>Вопрос 29

Что такое assembly manifest (манифест сборки)?

Ответ: Манифест сборки содержит все метаданные, необходимые для задания требований сборки к версиям и удостоверения безопасности, а также все метаданные, необходимые для определения области действия сборки и разрешения ссылок на ресурсы и классы. Манифест сборки может храниться в PE-файле (EXE или DLL) с кодом MSIL или же в отдельном PE-файле, содержащем только данные манифеста.

Манифест сборки предназначен для следующих задач:

    перечисление файлов, составляющих сборку;
    сопоставление ссылок на типы и ресурсы сборки с файлами, содержащими объявления и реализации этих типов и ресурсов;
    перечисление других сборок, от которых зависит эта сборка;
    обеспечение косвенного обращения пользователей сборки к подробностям ее реализации;
    предоставление собственного описания сборки;

Жмяк на ссылку
<details><summary>Вопрос 30

Что такое GAC? Возможно ли поместить два файла с одинаковым именем в Global Assembly Cache?

Ответ: GAC (Global Assembly Cache) - глобальный кэш сборок, место где хранятся разделяемые сборки. Местоположение кэша сборок отличается в зависимости от версии .NET, установленной на локальной машине. До .NET 4.0 глобальный кэш находился в каталоге C:\Windows\assembly. Начиная же с версии .NET 4.0 кэш сборок размещается по пути C:\Windows\Microsoft.NET\assembly\GAC_MSIL.

В GAC нельзя помещать полностью одинаковые сборки (сборки с полностью совпадающим сложным именем). Сложное имя сборки состоит из нескольких частей:

    Имя сборки без расширения
    Номер версии. Благодаря разграничению по версии можно использовать разные версии одной и ой же сборки
    Открытый ключ
    Необязательное значение для культуры (при локализации сборки)
    Цифровая подпись, которая создается с помощью хэш-значения содержимого сборки и значения секретного ключа. Секретный ключ представляет собой файл с расширением *.snk.

Так, что если совпадает у двух сборок только имена сборки, а все остальное отличается, то их можно помещать в GAC вместе.
