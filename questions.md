## Список теоритических вопросов по C# со скрытыми ответами для самопроверки
Ответы даны не мной и могут содержать ошибки, нет смысла их заучивать. Однако, если вы не можете ответить или ваш ответ сильно отличается, то вероятно у вас пробелы по данному вопросу и стоит провести более глубокое его изучение.

Нумерация в порядке согласно [источнику](https://metanit.com/sharp/interview/), все практические вопросы пропущены.
Автор ответов - [@maddevelop](https://teletype.in/@maddevelop).

<details><summary>Вопрос 9. Является ли тип List потокобезопасной (thread-safe) коллекцией?</summary>

>Тип List может быть потокобезопасным в операциях чтения.   
>Пользовательский код должен обеспечивать всю синхронизацию при параллельном добавлении элементов в несколько потоков или удалении элементов из них.
</details>

<details><summary>Вопрос 10. В чем различие между операцией cast (приведения типов) и оператором as?</summary>

>В случае ошибки cast выбрасывает исключение InvalidCastException, а оператор as возвращает null
</details>

<details><summary>Вопрос 11. Какова алгоритмическая сложность для операций чтения и записи для коллекции Dictionary?</summary>

>Чтение очень быстрое, потому что используются хэш-таблицы и сложность в этом случае стремится к O(1).   
>Запись проходит тоже очень быстро (O(1)), в том случае если .Count меньше емкости, если же больше, то скорость стремится к O(n).
</details>

<details><summary>Вопрос 12. В чем различие между ключевыми словами "ref" и "out"?</summary>

>Параметр с ключевым слово out может быть не инициализирован, а параметр с ключевым словом ref обязательно должен быть инииализирован до вызова метода, который использует эти параметры.
</details>

<details><summary>Вопрос 15. В чем отличие необязательных параметров от именованных?</summary>

>Необязательные параметры позволяют опускать аргументы функции, в то время как именованные параметры разрешают передавать аргументы по названию параметра.   
>Можно, например присвоить второму и третьему параметру функции значения по-умолчанию:
```csharp
public void optionalParamFunc(int p1, int p2 = 2, int p3 = 3); 
optionalParamFunc(1, p3:10); //это эквивалентно optionalParamFunc(1,2,10);
```
</details>

<details><summary>Вопрос 16. Чем отличаются друг от друга классы String и StringBuilder?</summary>

>Объект класса String представляет собой неизменяемую строку.   
>Когда выполняется какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места.   
>Объект класса StringBuilder представляет собой динамическую строку.   
>При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке, а при добавлении к ней каких-либо элементов строка не пересоздается заново.   
>В том случае если выделенной памяти не будет хватать для добавления новых элементов, то емкость объекта будет увеличена.
</details>

<details><summary>Вопрос 17. Какие отличие между значимыми и ссылочными типами?</summary>

>Значимые типы (value type) хранятся в стеке. Стек - это структура данных, которая растет снизу вверх: каждый новый элемент помещаются поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве. А ссылочные типы (reference type) хранятся в куче, это другая область памяти, которую можно представить как неупорядоченный набор различных объектов. Когда создаётся объект ссылочного типа в стеке помещается ссылка на адрес в куче. Когда этот объект перестает использоваться, то ссылка уничтожается, а память в куче очищается.
</details>

<details><summary>Вопрос 18. Как и зачем использовать конструкцию using в C#?</summary>

>Ключевое слово using упрощает работу с объектами которые реализуют интерфейс IDisposable.   
>Интерфейс IDisposable содержит один метод .Dispose(), который используется для освобождения ресурсов, которые захватил объект. При использовании using не обязательно явно вызывать .Dispose() для объекта.
</details>

<details><summary>Вопрос 19. В чем отличие использования Finalize и Dispose?</summary>

>Dispose нужен для освобождения ресурсов "здесь и сейчас" (а точнее вызов Dispose сигнализирует, что нужно освободить ресурс, но не факт это случится в тот же момент). Необходимость и преимущество интерфейса IDisposable именно в том, что его реализация позволяет освобождать ресурсы не тогда, когда до них доберется сборщик мусора, а тогда, когда это нужно программисту. Ресурсы могут быть дорогими, и держать их в памяти неопределенно долгое время может быть слишком расточительным.   
>Что качается деструкторов в C#, то их нет вовсе, но есть финализаторы. Разница в том, что время вызова финализатора не определено. Его вызвать вручную нельзя это делается автоматически, в отличии от Dispose, который предназначен для такого.   
>Finalize выполняется перед уничтожением объекта. Можно сказать, что это "последний шанс" освободить ресурсы корректно. Определять этот метод имеет смысл только в случае, если класс имеет доступ к каким-либо неуправляемым ресурсам.
</details>

<details><summary>Вопрос 20. В чем основные отличия класса от структуры в языке C#?</summary>

>Основные отличия класса от структуры следующие: 
>1. Структура является размерным типом, а класс – ссылочным.
>2. Все структурные типы неявно наследуются от System.ValueType, они не бывают абстрактными и всегда неявно запечатаны (sealed)
>3. При присваивании переменных структурного типа, создается копия данных
>4. Объявления полей структуры не могут иметь инициализаторов
>5. Различная интерпретация this для структуры и класса
>6. Структура не может содержать конструктор без параметров
>7. Структура не может содержать деструктор
>8. Для ссылочных типов значение по умолчанию – null
>9. При конвертировании между ссылочным и размерным типами происходит упаковка и распаковка.
</details>

<details><summary>Вопрос 21. Как можно сравнить строки в C#?</summary>

>Согласно MSDN существует несколько методов для сравнения строк:
>    String.Compare - Сравнивает значения двух строк. Возвращает целочисленное значение.   
>    String.CompareOrdinal - Сравнивает две строки без учета локального языка и региональных параметров.Возвращает целочисленное значение.   
>    String.CompareTo - Сравнивает текущий строковый объект с другой строкой. Возвращает целочисленное значение.   
>    String.StartsWith - Определяет, начинается ли строка с переданной строки. Возвращает логическое значение.   
>    String.EndsWith - Определяет, заканчивается ли строка переданной строкой. Возвращает логическое значение.   
>    String.Equals - Определяет, совпадают ли две строки. Возвращает логическое значение.   
>    String.IndexOf - Возвращает индекс позиции символа или строки начиная с начала проверяемой строки. Возвращает целочисленное значение.   
>    String.LastIndexOf - Возвращает индекс позиции символа или строки начиная с конца проверяемой строки. Возвращает целочисленное значение.   
>    Так же можно использовать операторы != и ==.
</details>

<details><summary>Вопрос 22. Что такое управляемый код и CLR? Основные требования к управляемому коду.</summary>

>Управляемый код - код программы исполняемый под управлением CLR (Виртуальной машиной .Net).   
>CLR (общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.   
>Написанный управляемый код должен быть полностью совместим с CTS(Common Type System), который поддерживают все .Net совместимые языки.
</details>
	
<details><summary>Вопрос 23. Разница IEnumerable<T> и IQueryable<T> при работе с удаленной БД?</summary>

>IEnumerable. Объект IEnumerable представляет набор данных в памяти и может перемещаться по этим данным только вперед.   
>IQueryable. Он располагается в пространстве имен System.Linq. Объект предоставляет удаленный доступ к базе данных и позволяет перемещаться по данным как в прямом порядке от начала до конца, так и в обратном порядке. В процессе же выполнения запроса, происходит оптимизация запроса.
```csharp
IEnumerable<Phone> phoneIEnum = db.Phones;
var phones1 = phoneIEnum.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES, фильтрация на стороне клиента
IQueryable<Phone> phoneIQuer = db.Phones;
int id = 3;
var phones2 = phoneIQuer.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES WHERE ID > 3
```
</details>

<details><summary>Вопрос 24. Что такое абстракция и как она связана с ООП?</summary>

>Под абстракцией понимается модель реальной жизни упрощенная для решения конкретной задачи, которая выражена в объекте, т.е. любой объект - это абстракция, т.к. она только частично описывает реальную сущность. Поэтому любой объект можно считать абстракцией и он только частично описывает реальную сущность. Во время преобразования реальных сущностный в объект, то он лишается тех характеристик, которые являются несущественными деталями.   
>Например можно составить упрощенный класс человека, который умеет двигаться, а от всего остального мы абстрагируемся (в данным случае несущественно то, что он умеет дышать, кушать, видеть, слышать и т. д.)
</details>

<details><summary>Вопрос 25. Что такое IoC (Inversion of Control/инверсия управления) и для чего она нужна?</summary>

>Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
</details>
	
<details><summary>Вопрос 26. Что такое DI (Dependency Injection) контейнер?</summary>

>DI контейнер это один из способов реализации принципа IoC. Этот контейнер знает о всех интерфейсах и их реализациях в системе и умеет их сопоставлять. Перед началом работы с ним необходимо зарегистрировать известные типы и их сопоставления(интерфейс-->реализация).
</details>

<details><summary>Вопрос 27. Какие реализации DI контейнеров вы знаете на C#. Какой DI контейнер является лучшим?</summary>

>Castle Windsor, Autofac, Ninject, Unity...и так далее, на самом деле их очень много. На счет того, какой из них лучший не совсем корректный вопрос. Все зависит от конкретной реализации.
</details>

<details><summary>Вопрос 28. Что подразумевается под свойствами в C#?</summary>

>В C# существуют специальные методы доступа, которые и именуются свойствами. Они обеспечивают простой доступ к полям класса для получения или установки их значения
>Стандартной определение свойства содержит блоки get и set. В блоке get возвращается значение поля, а в блоке set устанавливается с помощью параметра value, которое представляет передаваемое значение.
</details>

<details><summary>Вопрос 29. Что такое assembly manifest (манифест сборки)?</summary>

>Манифест сборки содержит все метаданные, необходимые для задания требований сборки к версиям и удостоверения безопасности, а также все метаданные, необходимые для определения области действия сборки и разрешения ссылок на ресурсы и классы. Манифест сборки может храниться в PE-файле (EXE или DLL) с кодом MSIL или же в отдельном PE-файле, содержащем только данные манифеста.   
>Манифест сборки предназначен для следующих задач:
>    * перечисление файлов, составляющих сборку;
>    * сопоставление ссылок на типы и ресурсы сборки с файлами, содержащими объявления и реализации этих типов и ресурсов;
>    * перечисление других сборок, от которых зависит эта сборка;
>    * обеспечение косвенного обращения пользователей сборки к подробностям ее реализации;
>    * предоставление собственного описания сборки;
</details>
	
<details><summary>Вопрос 30. Что такое GAC? Возможно ли поместить два файла с одинаковым именем в Global Assembly Cache?</summary>

>GAC (Global Assembly Cache) - глобальный кэш сборок, место где хранятся разделяемые сборки. Местоположение кэша сборок отличается в зависимости от версии .NET, установленной на локальной машине.
>В GAC нельзя помещать полностью одинаковые сборки (сборки с полностью совпадающим сложным именем). Сложное имя сборки состоит из нескольких частей:
>    * Имя сборки без расширения
>    * Номер версии. Благодаря разграничению по версии можно использовать разные версии одной и ой же сборки
>    * Открытый ключ
>    * Необязательное значение для культуры (при локализации сборки)
>    * Цифровая подпись, которая создается с помощью хэш-значения содержимого сборки и значения секретного ключа. Секретный ключ представляет собой файл с расширением *.snk.
>Так, что если совпадает у двух сборок только имена сборки, а все остальное отличается, то их можно помещать в GAC вместе.
</details>
